<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>MiniCraft Babylon</title>
  <style>
    html, body {
      margin: 0;
      overflow: hidden;
      width: 100%;
      height: 100%;
      background: lightblue;
      font-family: sans-serif;
    }
    canvas {
      width: 100%;
      height: 100%;
      display: block;
    }
    #inventory {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 8px;
      background: rgba(255,255,255,0.8);
      padding: 6px 12px;
      border-radius: 8px;
    }
    .block-btn {
      width: 30px;
      height: 30px;
      border: 2px solid #333;
      cursor: pointer;
    }
    .selected {
      border-color: red;
    }
    #selectedLabel {
      position: absolute;
      bottom: 50px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.6);
      color: white;
      padding: 4px 10px;
      border-radius: 6px;
      font-size: 14px;
    }
    #crosshair {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 10px;
      height: 10px;
      background: black;
      border-radius: 50%;
      pointer-events: none;
    }
  </style>
</head>
<body>
<canvas id="renderCanvas"></canvas>
<div id="inventory"></div>
<div id="selectedLabel">Selected: grass</div>
<div id="crosshair"></div>

<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/cannon.js"></script>
<script>
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);
const scene = new BABYLON.Scene(engine);
scene.enablePhysics(new BABYLON.Vector3(0, -9.81, 0), new BABYLON.CannonJSPlugin());
scene.collisionsEnabled = true;
scene.clearColor = new BABYLON.Color3.FromHexString("#87CEFA"); // sky

const blockColors = {
  grass: "#00aa00",
  dirt: "#8B4513",
  stone: "#808080",
  coal: "#404040",
  iron: "#b87333",
  gold: "#FFD700",
  redstone: "#FF0000",
  diamond: "#00CED1",
  lava: "#FF4500",
  water: "#1E90FF",
  leaves: "#006400",
  logs: "#4b2e2e",
  bedrock: "#000000"
};

let selectedBlock = "grass";

// Inventory UI
const inventory = document.getElementById("inventory");
const label = document.getElementById("selectedLabel");

Object.keys(blockColors).forEach(type => {
  const btn = document.createElement("div");
  btn.className = "block-btn";
  btn.style.background = blockColors[type];
  btn.onclick = () => {
    selectedBlock = type;
    document.querySelectorAll(".block-btn").forEach(b => b.classList.remove("selected"));
    btn.classList.add("selected");
    label.textContent = "Selected: " + selectedBlock;
  };
  inventory.appendChild(btn);
});
inventory.firstChild.classList.add("selected");

// First-person camera
const camera = new BABYLON.UniversalCamera("fpCamera", new BABYLON.Vector3(16, 20, 16), scene);
camera.attachControl(canvas, true);
camera.checkCollisions = true;
camera.applyGravity = true;
camera.ellipsoid = new BABYLON.Vector3(0.5, 1, 0.5);
camera.speed = 0.5;
camera.inertia = 0;
camera.angularSensibility = 500;

// Pointer lock
canvas.addEventListener("click", () => {
  canvas.requestPointerLock();
});

// Light
const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);

// Simple Perlin-like function
function perlin(x, z) {
  return Math.floor((Math.sin(x * 0.2) + Math.cos(z * 0.2)) * 2 + 5);
}

function createBlock(x, y, z, type, physics = false) {
  const box = BABYLON.MeshBuilder.CreateBox(`box-${x}-${y}-${z}`, { size: 1 }, scene);
  box.position.set(x, y, z);
  const mat = new BABYLON.StandardMaterial(`mat-${x}-${y}-${z}`, scene);
  mat.diffuseColor = BABYLON.Color3.FromHexString(blockColors[type]);
  box.material = mat;
  box.isPickable = true;
  box.checkCollisions = true;
  if (physics) {
    box.physicsImpostor = new BABYLON.PhysicsImpostor(box, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0 }, scene);
  }
  return box;
}

// Generate terrain
for (let x = 0; x < 32; x++) {
  for (let z = 0; z < 32; z++) {
    const h = perlin(x, z);
    for (let y = 0; y <= h; y++) {
      let type = "dirt";
      if (y === h) type = "grass";
      else if (y < h - 3) {
        const r = Math.random();
        if (r < 0.05) type = "diamond";
        else if (r < 0.1) type = "redstone";
        else if (r < 0.2) type = "coal";
        else if (r < 0.3) type = "iron";
        else if (r < 0.35) type = "gold";
        else type = "stone";
      }
      createBlock(x, y, z, type, true);
    }
    createBlock(x, -1, z, "bedrock", true);
  }
}

// WASD movement
const inputMap = {};
scene.actionManager = new BABYLON.ActionManager(scene);
scene.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnKeyDownTrigger, evt => {
  inputMap[evt.sourceEvent.key.toLowerCase()] = true;
}));
scene.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnKeyUpTrigger, evt => {
  inputMap[evt.sourceEvent.key.toLowerCase()] = false;
}));

scene.onBeforeRenderObservable.add(() => {
  const forward = camera.getDirection(BABYLON.Axis.Z);
  const right = camera.getDirection(BABYLON.Axis.X);
  if (inputMap["w"]) camera.position.addInPlace(forward.scale(camera.speed));
  if (inputMap["s"]) camera.position.addInPlace(forward.scale(-camera.speed));
  if (inputMap["a"]) camera.position.addInPlace(right.scale(-camera.speed));
  if (inputMap["d"]) camera.position.addInPlace(right.scale(camera.speed));
});

// Block placement
scene.onPointerDown = function () {
  const pick = scene.pick(scene.pointerX, scene.pointerY);
  if (pick.hit) {
    const normal = pick.getNormal(true);
    const pos = pick.pickedPoint.add(normal);
    const x = Math.floor(pos.x + 0.5);
    const y = Math.floor(pos.y + 0.5);
    const z = Math.floor(pos.z + 0.5);
    createBlock(x, y, z, selectedBlock, true);
  }
};

engine.runRenderLoop(() => {
  scene.render();
});
window.addEventListener("resize", () => {
  engine.resize();
});
</script>
</body>
</html>
