<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>MiniCraft Babylon</title>
  <style>
    html, body {
      margin: 0;
      overflow: hidden;
      width: 100%;
      height: 100%;
      background: lightblue;
      font-family: sans-serif;
    }
    canvas {
      width: 100%;
      height: 100%;
      display: block;
    }
    #crosshair {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 10px;
      height: 10px;
      background: black;
      border-radius: 50%;
      pointer-events: none;
    }
  </style>
</head>
<body>
<canvas id="renderCanvas"></canvas>
<div id="crosshair"></div>

<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/cannon.js"></script>
<script>
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);
const scene = new BABYLON.Scene(engine);
scene.enablePhysics(new BABYLON.Vector3(0, -9.81, 0), new BABYLON.CannonJSPlugin());
scene.collisionsEnabled = true;
scene.clearColor = new BABYLON.Color3.FromHexString("#87CEFA"); // sky

const blockColors = {
  grass: "#00aa00",
  dirt: "#8B4513",
  stone: "#808080",
  bedrock: "#000000"
};

// Simple Perlin-like function
function perlin(x, z) {
  return Math.floor((Math.sin(x * 0.2) + Math.cos(z * 0.2)) * 2 + 5);
}

function createBlock(x, y, z, type) {
  const box = BABYLON.MeshBuilder.CreateBox(`box-${x}-${y}-${z}`, { size: 1 }, scene);
  box.position.set(x, y, z);
  const mat = new BABYLON.StandardMaterial(`mat-${x}-${y}-${z}`, scene);
  mat.diffuseColor = BABYLON.Color3.FromHexString(blockColors[type]);
  box.material = mat;
  box.checkCollisions = true;
  box.physicsImpostor = new BABYLON.PhysicsImpostor(box, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0 }, scene);
}

// Generate terrain
for (let x = 0; x < 32; x++) {
  for (let z = 0; z < 32; z++) {
    const h = perlin(x, z);
    for (let y = 0; y <= h; y++) {
      const type = y === h ? "grass" : "dirt";
      createBlock(x, y, z, type);
    }
    createBlock(x, -1, z, "bedrock");
  }
}

// First-person camera
const camera = new BABYLON.UniversalCamera("fpCamera", new BABYLON.Vector3(16, 20, 16), scene);
camera.attachControl(canvas, true);
camera.checkCollisions = true;
camera.applyGravity = true;
camera.ellipsoid = new BABYLON.Vector3(0.5, 1, 0.5);
camera.speed = 0.5;
camera.inertia = 0;
camera.angularSensibility = 500;

// Pointer lock
canvas.addEventListener("click", () => {
  canvas.requestPointerLock();
});

// Light
const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);

// WASD movement
const inputMap = {};
scene.actionManager = new BABYLON.ActionManager(scene);
scene.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnKeyDownTrigger, evt => {
  inputMap[evt.sourceEvent.key.toLowerCase()] = true;
}));
scene.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnKeyUpTrigger, evt => {
  inputMap[evt.sourceEvent.key.toLowerCase()] = false;
}));

scene.onBeforeRenderObservable.add(() => {
  const forward = camera.getDirection(BABYLON.Axis.Z);
  const right = camera.getDirection(BABYLON.Axis.X);
  if (inputMap["w"]) camera.position.addInPlace(forward.scale(camera.speed));
  if (inputMap["s"]) camera.position.addInPlace(forward.scale(-camera.speed));
  if (inputMap["a"]) camera.position.addInPlace(right.scale(-camera.speed));
  if (inputMap["d"]) camera.position.addInPlace(right.scale(camera.speed));
});

engine.runRenderLoop(() => {
  scene.render();
});
window.addEventListener("resize", () => {
  engine.resize();
});
</script>
</body>
</html>
