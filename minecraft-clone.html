// ...existing code...
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mini Minecraft Clone — Single File (Babylon)</title>

<!-- Babylon.js -->
<script src="https://cdn.babylonjs.com/babylon.js"></script>

<style>
  html,body{height:100%;margin:0;overflow:hidden;font-family:system-ui,Segoe UI,Roboto,Arial}
  #renderCanvas{width:100%;height:100%;display:block;background:linear-gradient(#87ceeb, #cde9ff)}
  #hud{position:fixed;left:12px;top:12px;z-index:20;background:rgba(255,255,255,0.8);padding:8px;border-radius:8px}
  #palette{display:flex;gap:6px;margin-top:8px}
  .slot{width:36px;height:36px;border-radius:6px;border:2px solid transparent;display:flex;align-items:center;justify-content:center;font-weight:700;cursor:pointer}
  .slot.sel{outline:3px solid #111}
  #centerCross{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);width:12px;height:12px;border-radius:50%;background:rgba(0,0,0,0.6);z-index:10;pointer-events:none}
  #help{position:fixed;right:12px;top:12px;background:rgba(255,255,255,0.85);padding:8px;border-radius:8px;font-size:13px}
  button{cursor:pointer}
</style>
</head>
<body>
  <canvas id="renderCanvas"></canvas>
  <div id="hud">
    <div>Selected: <span id="selName">Grass</span></div>
    <div id="palette"></div>
    <div style="margin-top:8px">Break: LMB — Place: RMB — 1-9 select</div>
  </div>
  <div id="help">Click to lock pointer. WASD move, Space jump</div>
  <div id="centerCross"></div>

<script>
(() => {
  const canvas = document.getElementById('renderCanvas');
  const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: false, stencil: true });
  const scene = new BABYLON.Scene(engine);
  scene.clearColor = new BABYLON.Color3(0.53,0.8,1);

  // --- Block definitions (colors per request) ---
  // 0=air
  const BLOCKS = [
    { id:0, name:'Air', color:null },
    { id:1, name:'Grass', color:0x008f11 },        // green
    { id:2, name:'Dirt', color:0x8b5a2b },         // brown
    { id:3, name:'Stone', color:0x999999 },        // gray stone
    { id:4, name:'Coal', color:0x0b0b0b },         // black
    { id:5, name:'Iron', color:0xd2b48c },         // light brown/gray-ish
    { id:6, name:'Redstone', color:0xff3333 },     // red
    { id:7, name:'Gold', color:0xffd000 },         // yellow
    { id:8, name:'Water', color:0x3f8efc },        // blue
    { id:9, name:'Log', color:0x4b2e19 },          // dark brown logs
    { id:10,name:'Leaves', color:0x114411 }        // dark green leaves
  ];

  // world parameters
  const R = 22; // radius x/z (world will be roughly (2R+1)^2)
  const MAX_H = 18; // height
  const world = new Map(); // key -> id
  const instances = new Map(); // key -> InstancedMesh (for removal)
  function key(x,y,z){ return `${x},${y},${z}`; }
  function getBlock(x,y,z){ return world.get(key(x,y,z)) || 0; }
  function setBlock(x,y,z,id){
    const k = key(x,y,z);
    const old = world.get(k) || 0;
    if (old === id) return;
    // remove old instance if present
    const oldInst = instances.get(k);
    if (oldInst){ try{ oldInst.dispose(); } catch(e){} instances.delete(k); }
    if (id === 0){ world.delete(k); return; }
    world.set(k,id);
    // create instance for mesh pool
    const base = meshPool.get(id);
    if (base){
      const inst = base.createInstance(k);
      inst.position.set(x + 0.5, y + 0.5, z + 0.5);
      inst.rotationQuaternion = null;
      inst.isPickable = false;
      instances.set(k, inst);
    }
  }

  // --- basic scene: light + camera ---
  const hemi = new BABYLON.HemisphericLight('h', new BABYLON.Vector3(0.6,1,0.4), scene);
  hemi.intensity = 0.9;
  const dir = new BABYLON.DirectionalLight('d', new BABYLON.Vector3(-0.5,-1,0.5), scene);
  dir.position = new BABYLON.Vector3(40,60,20);
  dir.intensity = 0.6;

  // camera/player (we implement our own physics)
  const camera = new BABYLON.FreeCamera('playerCam', new BABYLON.Vector3(0,6,0), scene);
  camera.fov = 0.9;
  camera.attachControl(canvas, true);
  // pointer lock on click
  canvas.addEventListener('click', ()=> {
    if (document.pointerLockElement !== canvas) canvas.requestPointerLock?.();
  });
  // disable default camera inputs (we handle manually)
  camera.inputs.clear();

  // simple cursor orientation via pointerlock mousemove
  let yaw = 0, pitch = 0;
  const PI_2 = Math.PI/2;
  document.addEventListener('pointerlockchange', () => {
    // nothing
  });
  window.addEventListener('mousemove', (e) => {
    if (document.pointerLockElement !== canvas) return;
    const sensitivity = 0.0022;
    // Fix: use natural mapping: move mouse right => increase yaw (look right)
    yaw += e.movementX * sensitivity;
    // Fix: move mouse up => look up (decrease pitch)
    pitch -= e.movementY * sensitivity;
    pitch = Math.max(-PI_2 + 0.1, Math.min(PI_2 - 0.1, pitch));
    camera.rotation = new BABYLON.Vector3(pitch, yaw, 0);
  });

  // --- mesh pool (one base box per block type) ---
  const meshPool = new Map();
  for (let b of BLOCKS){
    if (b.id === 0) continue;
    const mat = new BABYLON.StandardMaterial('m'+b.id, scene);
    mat.diffuseColor = BABYLON.Color3.FromHexString('#' + b.color.toString(16).padStart(6,'0'));
    mat.specularColor = new BABYLON.Color3(0.1,0.1,0.1);
    mat.backFaceCulling = false;
    const box = BABYLON.MeshBuilder.CreateBox('box'+b.id, { size: 1 }, scene);
    box.material = mat;
    box.isVisible = false; // base not visible; instances will be visible
    box.checkCollisions = true;
    meshPool.set(b.id, box);
  }

  // ground/below plane (invisible collider floor for out-of-range)
  const floor = BABYLON.MeshBuilder.CreateGround('floor', {width:1000, height:1000}, scene);
  floor.position.y = -100;
  floor.isVisible = false;

  // --- terrain generation (simple smooth noise) ---
  function noise(x,z){
    return (Math.sin(x*0.12 + z*0.07) + Math.cos((x - z)*0.08) + Math.sin((x*0.15 - z*0.11)*0.9))*1.6;
  }
  function generateTerrain(){
    world.clear();
    // remove existing instances
    for (let inst of instances.values()){ try{ inst.dispose(); }catch{} }
    instances.clear();
    for (let x = -R; x <= R; x++){
      for (let z = -R; z <= R; z++){
        const h = Math.floor(6 + noise(x,z) * 3 + Math.sin((x*z)*0.01));
        for (let y = 0; y <= h; y++){
          let id = 2; // dirt
          if (y === h) id = 1; // grass
          else if (y <= h - 4) {
            id = 3; // stone
            const r = Math.random();
            if (r < 0.012) id = 4; // coal
            else if (r < 0.018) id = 5; // iron
            else if (r < 0.02) id = 6; // redstone
            else if (r < 0.022) id = 7; // gold
          }
          setBlock(x,y,z,id);
        }
        // water fill if low
        const hval = Math.floor(6 + noise(x,z) * 3);
        if (hval < 4){
          for (let y = hval+1; y <= 4; y++) setBlock(x,y,z,8);
        }
        // trees
        if (Math.random() < 0.04 && noise(x,z) > -1){
          const trunk = 3 + Math.floor(Math.random()*2);
          const baseH = Math.floor(6 + noise(x,z)*3);
          for (let t=1; t<=trunk; t++) setBlock(x, baseH + t, z, 9);
          const top = baseH + trunk;
          for (let ox=-2; ox<=2; ox++) for (let oz=-2; oz<=2; oz++){
            if (Math.abs(ox)+Math.abs(oz) < 4) setBlock(x+ox, top, z+oz, 10);
          }
        }
      }
    }
  }

  generateTerrain();

  // --- player physics (simple AABB) ---
  const player = {
    pos: new BABYLON.Vector3(0, 10, 0),
    vel: new BABYLON.Vector3(0, 0, 0),
    speed: 6,
    width: 0.6,
    height: 1.8,
    onGround: false
  };

  // simple AABB collision check against blocks in world
  function boxCollides(min, max){
    const x0 = Math.floor(min.x), x1 = Math.floor(max.x);
    const y0 = Math.floor(min.y), y1 = Math.floor(max.y);
    const z0 = Math.floor(min.z), z1 = Math.floor(max.z);
    for (let x = x0; x <= x1; x++){
      for (let y = y0; y <= y1; y++){
        for (let z = z0; z <= z1; z++){
          if (getBlock(x,y,z) !== 0) return true;
        }
      }
    }
    return false;
  }

  // raycast through voxel grid (step along ray) to pick block and face normal
  function raycastVoxel(origin, dir, maxDist=8){
    const step = 0.1;
    let t = 0;
    while (t < maxDist){
      const p = origin.add(dir.scale(t));
      const bx = Math.floor(p.x), by = Math.floor(p.y), bz = Math.floor(p.z);
      const id = getBlock(bx,by,bz);
      if (id !== 0){
        const local = p.subtract(new BABYLON.Vector3(bx+0.5, by+0.5, bz+0.5));
        const ax = Math.abs(local.x), ay = Math.abs(local.y), az = Math.abs(local.z);
        let face = new BABYLON.Vector3(0,0,0);
        if (ax > ay && ax > az) face.x = local.x > 0 ? 1 : -1;
        else if (ay > ax && ay > az) face.y = local.y > 0 ? 1 : -1;
        else face.z = local.z > 0 ? 1 : -1;
        return { pos: {x:bx,y:by,z:bz}, face };
      }
      t += step;
    }
    return null;
  }

  // --- input ---
  const input = { forward:false, back:false, left:false, right:false, jump:false };
  window.addEventListener('keydown', (e) => {
    if (e.key === 'w') input.forward = true;
    if (e.key === 's') input.back = true;
    if (e.key === 'a') input.left = true;
    if (e.key === 'd') input.right = true;
    if (e.code === 'Space') { if (player.onGround) player.vel.y = 9; }
    if (/^[1-9]$/.test(e.key)){ const idx = Number(e.key); if (idx < BLOCKS.length) { selected = idx; updatePalette(); } }
    if (e.key === 'r') { generateTerrain(); }
  });
  window.addEventListener('keyup', (e) => {
    if (e.key === 'w') input.forward = false;
    if (e.key === 's') input.back = false;
    if (e.key === 'a') input.left = false;
    if (e.key === 'd') input.right = false;
  });

  // pointer actions: LMB break, RMB place
  window.addEventListener('pointerdown', (ev) => {
    if (document.pointerLockElement !== canvas) return;
    // build ray in world space from camera
    const origin = camera.position.clone();
    // compute forward vector from yaw/pitch (avoid camera.rotationQuaternion dependency)
    const fx = Math.sin(yaw) * Math.cos(pitch);
    const fy = Math.sin(pitch);
    const fz = Math.cos(yaw) * Math.cos(pitch);
    const forward = new BABYLON.Vector3(fx, fy, fz).normalize();
    const hit = raycastVoxel(origin, forward, 8);
    if (!hit) return;
    if (ev.button === 0){
      // break
      setBlock(hit.pos.x, hit.pos.y, hit.pos.z, 0);
    } else if (ev.button === 2){
      // place
      const p = hit.pos;
      const f = hit.face;
      const placeX = p.x + f.x, placeY = p.y + f.y, placeZ = p.z + f.z;
      // don't place inside player
      const min = new BABYLON.Vector3(player.pos.x - player.width/2, player.pos.y, player.pos.z - player.width/2);
      const max = new BABYLON.Vector3(player.pos.x + player.width/2, player.pos.y + player.height, player.pos.z + player.width/2);
      if (!(placeX >= Math.floor(min.x) && placeX <= Math.floor(max.x) &&
            placeY >= Math.floor(min.y) && placeY <= Math.floor(max.y) &&
            placeZ >= Math.floor(min.z) && placeZ <= Math.floor(max.z))){
        setBlock(placeX, placeY, placeZ, selected);
      }
    }
  });
  window.addEventListener('contextmenu', (e)=> e.preventDefault());

  // --- UI palette ---
  const paletteEl = document.getElementById('palette');
  const selName = document.getElementById('selName');
  let selected = 1;
  function updatePalette(){
    selName.textContent = BLOCKS[selected].name;
    document.querySelectorAll('.slot').forEach(s => s.classList.toggle('sel', Number(s.dataset.id) === selected));
  }
  for (let b of BLOCKS){
    if (b.id === 0) continue;
    const el = document.createElement('div');
    el.className = 'slot';
    el.dataset.id = b.id;
    el.style.background = '#' + b.color.toString(16).padStart(6,'0');
    el.title = b.name;
    el.addEventListener('click', ()=> { selected = b.id; updatePalette(); });
    paletteEl.appendChild(el);
  }
  updatePalette();

  // --- world instance management note: instances map tracks instanced meshes per block coordinate ---
  // Already handled in setBlock()

  // --- main loop (physics + rendering) ---
  const gravity = -30;
  let last = performance.now();
  engine.runRenderLoop(() => {
    const now = performance.now();
    const dt = Math.min(0.05, (now - last) / 1000);
    last = now;

    // movement vector from yaw/pitch
    const forwardDir = new BABYLON.Vector3(Math.sin(yaw), 0, Math.cos(yaw));
    const rightDir = new BABYLON.Vector3(Math.cos(yaw), 0, -Math.sin(yaw));
    let move = new BABYLON.Vector3(0,0,0);
    if (input.forward) move.addInPlace(forwardDir);
    if (input.back) move.subtractInPlace(forwardDir);
    if (input.left) move.subtractInPlace(rightDir);
    if (input.right) move.addInPlace(rightDir);
    if (move.lengthSquared() > 0){
      move.normalize();
      move.scaleInPlace(player.speed * dt);
      // Fix hitbox stuttering: resolve X and Z separately
      // attempt X
      player.pos.x += move.x;
      const minX = new BABYLON.Vector3(player.pos.x - player.width/2, player.pos.y, player.pos.z - player.width/2);
      const maxX = new BABYLON.Vector3(player.pos.x + player.width/2, player.pos.y + player.height, player.pos.z + player.width/2);
      if (boxCollides(minX, maxX)){
        player.pos.x -= move.x;
      }
      // attempt Z
      player.pos.z += move.z;
      const minZ = new BABYLON.Vector3(player.pos.x - player.width/2, player.pos.y, player.pos.z - player.width/2);
      const maxZ = new BABYLON.Vector3(player.pos.x + player.width/2, player.pos.y + player.height, player.pos.z + player.width/2);
      if (boxCollides(minZ, maxZ)){
        player.pos.z -= move.z;
      }
    }

    // gravity
    player.vel.y += gravity * dt;
    const prevY = player.pos.y;
    player.pos.y += player.vel.y * dt;

    // vertical collision resolution (improved)
    const minV = new BABYLON.Vector3(player.pos.x - player.width/2, player.pos.y, player.pos.z - player.width/2);
    const maxV = new BABYLON.Vector3(player.pos.x + player.width/2, player.pos.y + player.height, player.pos.z + player.width/2);
    if (boxCollides(minV, maxV)){
      // if moving up (hit ceiling)
      if (player.vel.y > 0){
        // place player just below the collided top block
        const top = Math.floor(player.pos.y + player.height);
        player.pos.y = top - player.height - 0.001;
        player.vel.y = 0;
      } else {
        // falling: place player on top of block
        const below = Math.floor(player.pos.y);
        player.pos.y = below + 1e-3;
        player.vel.y = 0;
        player.onGround = true;
      }
    } else {
      player.onGround = false;
    }

    // small step correction to avoid sinking due to float error: keep player slightly above ground
    if (player.onGround){
      // ensure player is not inside the block below
      const footY = Math.floor(player.pos.y - 0.01);
      if (getBlock(Math.floor(player.pos.x), footY, Math.floor(player.pos.z)) !== 0){
        player.pos.y = footY + 1 + 1e-3;
      }
    }

    // place camera
    camera.position.set(player.pos.x, player.pos.y + 0.4, player.pos.z);

    scene.render();
  });

  // window resizing
  window.addEventListener('resize', ()=> engine.resize() );

  // regenerate button (R)
  // small help UI hooking already created via keyboard 'r'

  // done
})();
</script>
</body>
</html>