<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mini Minecraft Clone — Single File (Babylon)</title>

<!-- Babylon.js -->
<script src="https://cdn.babylonjs.com/babylon.js"></script>

<style>
  html,body{height:100%;margin:0;overflow:hidden;font-family:system-ui,Segoe UI,Roboto,Arial}
  #renderCanvas{width:100%;height:100%;display:block;background:linear-gradient(#87ceeb, #cde9ff)}
  #hud{position:fixed;left:12px;top:12px;z-index:20;background:rgba(255,255,255,0.9);padding:8px;border-radius:8px}
  #palette{display:flex;gap:6px;margin-top:8px;flex-wrap:wrap}
  .slot{width:36px;height:36px;border-radius:6px;border:2px solid transparent;display:flex;align-items:center;justify-content:center;font-weight:700;cursor:pointer}
  .slot.sel{outline:3px solid #111}
  #centerCross{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);width:12px;height:12px;border-radius:50%;background:rgba(0,0,0,0.6);z-index:10;pointer-events:none}
  #help{position:fixed;right:12px;top:12px;background:rgba(255,255,255,0.85);padding:8px;border-radius:8px;font-size:13px}
  button{cursor:pointer}
  /* mobile controls */
  #mobileControls{position:fixed;left:12px;bottom:12px;z-index:30;display:none;gap:8px}
  #mobileControls .dir{display:flex;gap:6px;margin-bottom:6px}
  #mobileControls button{width:56px;height:56px;border-radius:10px;border:none;background:rgba(255,255,255,0.92);font-weight:700}
  #mobileLookHint{position:fixed;right:12px;bottom:12px;background:rgba(255,255,255,0.9);padding:8px;border-radius:8px;z-index:30;display:none}
  @media (max-width:900px){
    #mobileControls{display:flex;flex-direction:column}
    #mobileLookHint{display:block}
  }
</style>
</head>
<body>
  <canvas id="renderCanvas"></canvas>
  <div id="hud">
    <div>Selected: <span id="selName">Grass</span></div>
    <div id="palette"></div>
    <div style="margin-top:8px">Break: LMB — Place: RMB — 1-9 select</div>
  </div>
  <div id="help">Click to lock pointer. WASD move, Space jump</div>
  <div id="centerCross"></div>

  <!-- Mobile controls -->
  <div id="mobileControls" aria-hidden="false">
    <div class="dir">
      <button id="mForward">▲</button>
    </div>
    <div class="dir">
      <button id="mLeft">◀</button>
      <button id="mBack">▼</button>
      <button id="mRight">▶</button>
    </div>
    <div style="display:flex;gap:6px">
      <button id="mJump">Jump</button>
      <button id="mBreak">Break</button>
      <button id="mPlace">Place</button>
    </div>
  </div>
  <div id="mobileLookHint">Drag right side to look</div>

<script>
(() => {
  // ...existing code...
  const canvas = document.getElementById('renderCanvas');
  const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: false, stencil: true });
  const scene = new BABYLON.Scene(engine);
  scene.clearColor = new BABYLON.Color3(0.53,0.8,1);

  // --- Block definitions (colors per request) ---
  const BLOCKS = [
    { id:0, name:'Air', color:null },
    { id:1, name:'Grass', color:0x008f11 },
    { id:2, name:'Dirt', color:0x8b5a2b },
    { id:3, name:'Stone', color:0x999999 },
    { id:4, name:'Coal', color:0x0b0b0b },
    { id:5, name:'Iron', color:0xd2b48c },
    { id:6, name:'Redstone', color:0xff3333 },
    { id:7, name:'Gold', color:0xffd000 },
    { id:8, name:'Water', color:0x3f8efc },
    { id:9, name:'Log', color:0x4b2e19 },
    { id:10,name:'Leaves', color:0x114411 }
  ];

  // world parameters
  const R = 22;
  const MAX_H = 32;
  const world = new Map();
  const instances = new Map();
  function key(x,y,z){ return `${x},${y},${z}`; }
  function getBlock(x,y,z){ return world.get(key(x,y,z)) || 0; }

  // mesh pool + instancing
  const meshPool = new Map();
  const instancesByBase = new Map();
  for (let b of BLOCKS){
    if (b.id === 0) continue;
    const mat = new BABYLON.StandardMaterial('m'+b.id, scene);
    mat.diffuseColor = BABYLON.Color3.FromHexString('#' + b.color.toString(16).padStart(6,'0'));
    mat.specularColor = new BABYLON.Color3(0.1,0.1,0.1);
    const box = BABYLON.MeshBuilder.CreateBox('box'+b.id, { size: 1 }, scene);
    box.material = mat;
    box.isVisible = false;
    meshPool.set(b.id, box);
    instancesByBase.set(b.id, []);
  }

  function createInstanceForBlock(x,y,z,id){
    const base = meshPool.get(id);
    if (!base) return null;
    const inst = base.createInstance(key(x,y,z));
    inst.position.set(x + 0.5, y + 0.5, z + 0.5);
    inst.isPickable = false;
    instances.set(key(x,y,z), inst);
    instancesByBase.get(id).push(inst);
    return inst;
  }

  function removeInstance(x,y,z){
    const k = key(x,y,z);
    const i = instances.get(k);
    if (i){ try{ i.dispose(); }catch(e){} instances.delete(k); }
  }

  function setBlock(x,y,z,id){
    const k = key(x,y,z);
    const old = world.get(k) || 0;
    if (old === id) return;
    removeInstance(x,y,z);
    if (id === 0){
      world.delete(k);
      return;
    }
    world.set(k,id);
    createInstanceForBlock(x,y,z,id);
  }

  // ground plane invisible
  const floor = BABYLON.MeshBuilder.CreateGround('floor', {width:1000, height:1000}, scene);
  floor.position.y = -100;
  floor.isVisible = false;

  // terrain generation
  function noise(x,z){
    return (Math.sin(x*0.12 + z*0.07) + Math.cos((x - z)*0.08) + Math.sin((x*0.15 - z*0.11)*0.9))*1.6;
  }
  function generateTerrain(){
    world.clear();
    // dispose all instances
    for (let inst of instances.values()){ try{ inst.dispose(); }catch{} }
    instances.clear();
    instancesByBase.forEach((arr)=>arr.length=0);
    for (let x = -R; x <= R; x++){
      for (let z = -R; z <= R; z++){
        const h = Math.floor(6 + noise(x,z) * 3 + Math.sin((x*z)*0.01));
        for (let y = 0; y <= h; y++){
          let id = 2;
          if (y === h) id = 1;
          else if (y <= h - 4) {
            id = 3;
            const r = Math.random();
            if (r < 0.012) id = 4;
            else if (r < 0.018) id = 5;
            else if (r < 0.02) id = 6;
            else if (r < 0.022) id = 7;
          }
          setBlock(x,y,z,id);
        }
        const hval = Math.floor(6 + noise(x,z) * 3);
        if (hval < 4){
          for (let y = hval+1; y <= 4; y++) setBlock(x,y,z,8);
        }
        if (Math.random() < 0.04 && noise(x,z) > -1){
          const trunk = 3 + Math.floor(Math.random()*2);
          const baseH = Math.floor(6 + noise(x,z)*3);
          for (let t=1; t<=trunk; t++) setBlock(x, baseH + t, z, 9);
          const top = baseH + trunk;
          for (let ox=-2; ox<=2; ox++) for (let oz=-2; oz<=2; oz++){
            if (Math.abs(ox)+Math.abs(oz) < 4) setBlock(x+ox, top, z+oz, 10);
          }
        }
      }
    }
  }

  generateTerrain();

  // find highest ground at integer x,z
  function findGroundHeight(ix, iz){
    for (let y = MAX_H; y >= -10; y--){
      if (getBlock(ix,y,iz) !== 0) return y;
    }
    return -999; // no ground found
  }

  // --- player / camera ---
  const camera = new BABYLON.FreeCamera('playerCam', new BABYLON.Vector3(0,6,0), scene);
  camera.attachControl(canvas, true);
  camera.inputs.clear();

  let yaw = 0, pitch = 0;
  const PI_2 = Math.PI/2;
  // pointer look
  canvas.addEventListener('click', ()=> {
    if (document.pointerLockElement !== canvas) canvas.requestPointerLock?.();
  });
  window.addEventListener('mousemove', (e) => {
    if (document.pointerLockElement !== canvas) return;
    const sensitivity = 0.0022;
    yaw += e.movementX * sensitivity;
    pitch -= e.movementY * sensitivity;
    pitch = Math.max(-PI_2 + 0.05, Math.min(PI_2 - 0.05, pitch));
    camera.rotation = new BABYLON.Vector3(pitch, yaw, 0);
  });

  const player = {
    pos: new BABYLON.Vector3(0, 0, 0),
    vel: new BABYLON.Vector3(0, 0, 0),
    speed: 6,
    width: 0.6,
    height: 1.8,
    onGround: false
  };

  // place player above ground safely
  function spawnPlayerAt(x=0,z=0){
    const ix = Math.round(x), iz = Math.round(z);
    const gy = findGroundHeight(ix, iz);
    if (gy > -900){
      player.pos.x = x;
      player.pos.z = z;
      player.pos.y = gy + 1.2; // a little above ground
    } else {
      player.pos.x = x;
      player.pos.z = z;
      player.pos.y = 12; // fallback
    }
    // if inside block, nudge upward until free
    for (let i=0;i<40;i++){
      const min = new BABYLON.Vector3(player.pos.x - player.width/2, player.pos.y, player.pos.z - player.width/2);
      const max = new BABYLON.Vector3(player.pos.x + player.width/2, player.pos.y + player.height, player.pos.z + player.width/2);
      if (!boxCollides(min, max)) break;
      player.pos.y += 0.6;
    }
    camera.position.set(player.pos.x, player.pos.y + 0.4, player.pos.z);
  }

  // initial spawn at center
  spawnPlayerAt(0,0);

  // collision helpers
  function boxCollides(min, max){
    const x0 = Math.floor(min.x), x1 = Math.floor(max.x);
    const y0 = Math.floor(min.y), y1 = Math.floor(max.y);
    const z0 = Math.floor(min.z), z1 = Math.floor(max.z);
    for (let x = x0; x <= x1; x++){
      for (let y = y0; y <= y1; y++){
        for (let z = z0; z <= z1; z++){
          if (getBlock(x,y,z) !== 0) return true;
        }
      }
    }
    return false;
  }

  // raycast voxel
  function raycastVoxel(origin, dir, maxDist=8){
    const step = 0.08;
    let t = 0;
    while (t < maxDist){
      const p = origin.add(dir.scale(t));
      const bx = Math.floor(p.x), by = Math.floor(p.y), bz = Math.floor(p.z);
      const id = getBlock(bx,by,bz);
      if (id !== 0){
        const local = p.subtract(new BABYLON.Vector3(bx+0.5, by+0.5, bz+0.5));
        const ax = Math.abs(local.x), ay = Math.abs(local.y), az = Math.abs(local.z);
        let face = new BABYLON.Vector3(0,0,0);
        if (ax > ay && ax > az) face.x = local.x > 0 ? 1 : -1;
        else if (ay > ax && ay > az) face.y = local.y > 0 ? 1 : -1;
        else face.z = local.z > 0 ? 1 : -1;
        return { pos: {x:bx,y:by,z:bz}, face };
      }
      t += step;
    }
    return null;
  }

  // --- input ---
  const input = { forward:false, back:false, left:false, right:false, jump:false };
  window.addEventListener('keydown', (e) => {
    if (e.key === 'w') input.forward = true;
    if (e.key === 's') input.back = true;
    if (e.key === 'a') input.left = true;
    if (e.key === 'd') input.right = true;
    if (e.code === 'Space') { if (player.onGround) player.vel.y = 9; }
    if (/^[1-9]$/.test(e.key)){ const idx = Number(e.key); if (idx < BLOCKS.length) { selected = idx; updatePalette(); } }
    if (e.key === 'r') { generateTerrain(); spawnPlayerAt(player.pos.x, player.pos.z); }
  });
  window.addEventListener('keyup', (e) => {
    if (e.key === 'w') input.forward = false;
    if (e.key === 's') input.back = false;
    if (e.key === 'a') input.left = false;
    if (e.key === 'd') input.right = false;
  });

  // pointer actions
  window.addEventListener('pointerdown', (ev) => {
    if (document.pointerLockElement !== canvas && window.innerWidth > 900) return;
    const origin = camera.position.clone();
    // forward from yaw/pitch
    const fx = Math.sin(yaw) * Math.cos(pitch);
    const fy = Math.sin(pitch);
    const fz = Math.cos(yaw) * Math.cos(pitch);
    const forward = new BABYLON.Vector3(fx, fy, fz).normalize();
    const hit = raycastVoxel(origin, forward, 8);
    if (!hit) return;
    if (ev.button === 0){
      setBlock(hit.pos.x, hit.pos.y, hit.pos.z, 0);
    } else if (ev.button === 2){
      const p = hit.pos, f = hit.face;
      const placeX = p.x + f.x, placeY = p.y + f.y, placeZ = p.z + f.z;
      const min = new BABYLON.Vector3(player.pos.x - player.width/2, player.pos.y, player.pos.z - player.width/2);
      const max = new BABYLON.Vector3(player.pos.x + player.width/2, player.pos.y + player.height, player.pos.z + player.width/2);
      if (!(placeX >= Math.floor(min.x) && placeX <= Math.floor(max.x) &&
            placeY >= Math.floor(min.y) && placeY <= Math.floor(max.y) &&
            placeZ >= Math.floor(min.z) && placeZ <= Math.floor(max.z))){
        setBlock(placeX, placeY, placeZ, selected);
      }
    }
  });
  window.addEventListener('contextmenu', (e)=> e.preventDefault());

  // mobile: touch look on right half
  let touchLook = false;
  let lastTouchX = 0, lastTouchY = 0;
  canvas.addEventListener('touchstart', (ev) => {
    for (let t of ev.touches){
      if (t.clientX > canvas.clientWidth * 0.5){
        touchLook = true;
        lastTouchX = t.clientX; lastTouchY = t.clientY;
        ev.preventDefault();
        break;
      }
    }
  }, { passive:false });
  canvas.addEventListener('touchmove', (ev) => {
    if (!touchLook) return;
    const t = ev.touches[0];
    if (!t) return;
    const dx = t.clientX - lastTouchX;
    const dy = t.clientY - lastTouchY;
    lastTouchX = t.clientX; lastTouchY = t.clientY;
    const sensitivity = 0.005;
    yaw += dx * sensitivity;
    pitch -= dy * sensitivity;
    pitch = Math.max(-PI_2 + 0.05, Math.min(PI_2 - 0.05, pitch));
    camera.rotation = new BABYLON.Vector3(pitch, yaw, 0);
    ev.preventDefault();
  }, { passive:false });
  canvas.addEventListener('touchend', (ev) => { touchLook = false; });

  // mobile control buttons
  const mForward = document.getElementById('mForward'), mBack = document.getElementById('mBack'),
        mLeft = document.getElementById('mLeft'), mRight = document.getElementById('mRight'),
        mJump = document.getElementById('mJump'), mBreak = document.getElementById('mBreak'),
        mPlace = document.getElementById('mPlace');
  function bindTouchBtn(el, downCb, upCb){
    if (!el) return;
    el.addEventListener('touchstart', (e)=>{ e.preventDefault(); downCb(); }, { passive:false });
    el.addEventListener('touchend', (e)=>{ e.preventDefault(); upCb(); }, { passive:false });
    el.addEventListener('mousedown', (e)=>{ e.preventDefault(); downCb(); });
    el.addEventListener('mouseup', (e)=>{ e.preventDefault(); upCb(); });
  }
  bindTouchBtn(mForward, ()=>input.forward = true, ()=>input.forward = false);
  bindTouchBtn(mBack, ()=>input.back = true, ()=>input.back = false);
  bindTouchBtn(mLeft, ()=>input.left = true, ()=>input.left = false);
  bindTouchBtn(mRight, ()=>input.right = true, ()=>input.right = false);
  bindTouchBtn(mJump, ()=>{ if (player.onGround) player.vel.y = 9; }, ()=>{});
  bindTouchBtn(mBreak, ()=> {
    // center ray
    const origin = camera.position.clone();
    const fx = Math.sin(yaw) * Math.cos(pitch);
    const fy = Math.sin(pitch);
    const fz = Math.cos(yaw) * Math.cos(pitch);
    const forward = new BABYLON.Vector3(fx, fy, fz).normalize();
    const hit = raycastVoxel(origin, forward, 8);
    if (hit) setBlock(hit.pos.x, hit.pos.y, hit.pos.z, 0);
  }, ()=>{});
  bindTouchBtn(mPlace, ()=> {
    const origin = camera.position.clone();
    const fx = Math.sin(yaw) * Math.cos(pitch);
    const fy = Math.sin(pitch);
    const fz = Math.cos(yaw) * Math.cos(pitch);
    const forward = new BABYLON.Vector3(fx, fy, fz).normalize();
    const hit = raycastVoxel(origin, forward, 8);
    if (hit){
      const p = hit.pos, f = hit.face;
      const placeX = p.x + f.x, placeY = p.y + f.y, placeZ = p.z + f.z;
      setBlock(placeX, placeY, placeZ, selected);
    }
  }, ()=>{});

  // --- UI palette ---
  const paletteEl = document.getElementById('palette');
  const selName = document.getElementById('selName');
  let selected = 1;
  function updatePalette(){
    selName.textContent = BLOCKS[selected].name;
    document.querySelectorAll('.slot').forEach(s => s.classList.toggle('sel', Number(s.dataset.id) === selected));
  }
  for (let b of BLOCKS){
    if (b.id === 0) continue;
    const el = document.createElement('div');
    el.className = 'slot';
    el.dataset.id = b.id;
    el.style.background = '#' + b.color.toString(16).padStart(6,'0');
    el.title = b.name;
    el.addEventListener('click', ()=> { selected = b.id; updatePalette(); });
    paletteEl.appendChild(el);
  }
  updatePalette();

  // --- main loop ---
  const gravity = -30;
  let last = performance.now();
  engine.runRenderLoop(() => {
    const now = performance.now();
    const dt = Math.min(0.05, (now - last) / 1000);
    last = now;

    // movement
    const forwardDir = new BABYLON.Vector3(Math.sin(yaw), 0, Math.cos(yaw));
    const rightDir = new BABYLON.Vector3(Math.cos(yaw), 0, -Math.sin(yaw));
    let move = new BABYLON.Vector3(0,0,0);
    if (input.forward) move.addInPlace(forwardDir);
    if (input.back) move.subtractInPlace(forwardDir);
    if (input.left) move.subtractInPlace(rightDir);
    if (input.right) move.addInPlace(rightDir);
    if (move.lengthSquared() > 0){
      move.normalize();
      move.scaleInPlace(player.speed * dt);
      // resolve X then Z separately
      player.pos.x += move.x;
      const minX = new BABYLON.Vector3(player.pos.x - player.width/2, player.pos.y, player.pos.z - player.width/2);
      const maxX = new BABYLON.Vector3(player.pos.x + player.width/2, player.pos.y + player.height, player.pos.z + player.width/2);
      if (boxCollides(minX, maxX)) player.pos.x -= move.x;
      player.pos.z += move.z;
      const minZ = new BABYLON.Vector3(player.pos.x - player.width/2, player.pos.y, player.pos.z - player.width/2);
      const maxZ = new BABYLON.Vector3(player.pos.x + player.width/2, player.pos.y + player.height, player.pos.z + player.width/2);
      if (boxCollides(minZ, maxZ)) player.pos.z -= move.z;
    }

    // gravity
    player.vel.y += gravity * dt;
    player.pos.y += player.vel.y * dt;

    // vertical collision
    const minV = new BABYLON.Vector3(player.pos.x - player.width/2, player.pos.y, player.pos.z - player.width/2);
    const maxV = new BABYLON.Vector3(player.pos.x + player.width/2, player.pos.y + player.height, player.pos.z + player.width/2);
    if (boxCollides(minV, maxV)){
      if (player.vel.y > 0){
        // hit ceiling: push down slightly
        player.pos.y -= 0.05;
        player.vel.y = 0;
      } else {
        // landed on ground: snap to top of block
        const foot = Math.floor(player.pos.y);
        player.pos.y = foot + 1e-3;
        player.vel.y = 0;
        player.onGround = true;
      }
    } else {
      player.onGround = false;
    }

    // small correction
    if (player.onGround){
      const footY = Math.floor(player.pos.y - 0.01);
      if (getBlock(Math.floor(player.pos.x), footY, Math.floor(player.pos.z)) !== 0){
        player.pos.y = footY + 1 + 1e-3;
      }
    }

    // set camera
    camera.position.set(player.pos.x, player.pos.y + 0.4, player.pos.z);

    scene.render();
  });

  window.addEventListener('resize', ()=> engine.resize());

  // expose regenerate and spawn
  window.regenerate = () => { generateTerrain(); spawnPlayerAt(player.pos.x, player.pos.z); };

  // ...existing code...
})();
</script>
</body>